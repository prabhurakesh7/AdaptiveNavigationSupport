javacc distinguish token context 
basic requirement keyword identifier distinguish token context keyword allowed variable named hard href https github wenerme bbvm commit 2a6577ba05d332c5a331f8f3f389745822dd1f36 rel nofollow source href https github wenerme bbvm blob 2a6577ba05d332c5a331f8f3f389745822dd1f36 bbvm core src main jjtree wener bbvm asm bbasmparser jjt rel nofollow distinguish token context works fussy add lot extra state maintain lot states easy achieve 

ways outlined href http www engr mun ca theo javacc faq rel nofollow javacc faq ul li lexical states method tricky deal situations length longest match depends context rules skipping depend context problem complex li li token kind semantic lookahead based token image parser treat tokens specially circumstances faq li li easiest approach make distinctions lexical level ignore distinctions syntactic level deal keywords double identifiers li ul ill give examples approach hr h2 keywords identifiers h2 keyword strong class strong variable simple lexer put usual rules parser write production parser hr h2 original posters assembler h2 turning assembler original question lets jpc instruction jpc jump conditional instruction comparison operator operand number things including identifiers identifier named jpc valid jpc instructions lexical part parser hr suggest excluding register names list keywords identifiers include list ambiguity operand ambiguity parses context operand tokens r0 parsed registers identifiers luckly javacc prefer earlier choices happen warning javacc ignore warning add comment source code programmers dont worry suppress warning lookahead specification hr h2 context h2 examples left context treat token based solely sequence tokens left lets case interpretation keyword based tokens simple imperative language keywords variable names grammar unambiguous make grammar complicated adding kinds statements expressions left hand sides long grammar stays unambiguous complications wont make difference feel free experiment grammar ll places choice made based future token choice token block ahead place ahead end encountered start block solve 
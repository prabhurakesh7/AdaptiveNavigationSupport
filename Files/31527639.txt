dynamically choose method runtime alternatives visitor pattern reflection 
working small game template world comprised nodes multiple objects multiple objects implements interface methods execute single node recursively tree node compound issue pluggable system meaning players developers add types tree fly considered casting base types initially drawn href https en wikipedia org wiki visitor pattern rel nofollow visitor pattern advantage double dispatch allowing routine visitor act type visited caused complications specifically add type tree alternative wrote href https github floralvikings jenjin blob node overhaul jenjin world core src main jenjinstudios world reflection dynamicmethodselector rel nofollow utility class reflection find specific method applicable href http stackoverflow questions reflection performance concern performance fairly large number reflective lookups calls worried performance game hundreds thousands calls suffer solve problem patterns makes code uglier options allowing dynamic dispatch missing obscure ol li visitor pattern ul li pros ul li double dispatch li li performance li li clean code tasks li ul li li cons ul li difficult add types impossible modifying original code li li ugly code invocation tasks li ul li ul li li dynamic invocation reflection ul li pros ul li add types abandon li li customizable tasks li li clean code tasks li ul li li cons ul li poor performance li li ugly code invocation tasks li ul li ul li li casting ul li pros ul li performant reflection li li potentially dynamic visitor li li clean code invocation tasks li ul li li cons ul li code smell li li performant visitor double dispatch casting invocation li li ugly code tasks li ul li ul li ol missed familiar gang patterns href http gameprogrammingpatterns rel nofollow game programming patterns appreciated strong clear strong alternative approaches 

research lambdas constructed reflectively idea creating object obtained reflectively argument instance method invoked argument actual argument method created cached parameter type method key invoked method invocation eliminates invocation overhead incurred reflection couple issues constraints ul li parameter passed method argument method instance method invoked ul li fine purposes pass argument li ul li li trivial performance overhead invoking method parameter types havent searched reflectively ul li purposes number acceptable node types large quickly cached discovery method combinations parameter types overhead small constant simple lookup li ul li li requires li ul clarify code bit custom functional interface class javas performance 
multiple conditions multiple locks 
thread data structure needed protect access central data structure byte array choosing reentrantlocks case fairness policy advanced capabilities creating multiple conditions conditions concurrency complex listed ol li central byte array protected exclusively thread li li accessing methods foo bar run concurrently blocking internally access central byte array li li calls method foo bar exclusive multiple calls foo threads result thread blocking li ol original implementation chose implement nested locks structure equivalent method simply lock object additionally code reduced complex multi condition awaits signals single condition simplicity feel code unnecessarily complex obscure locks nested share finally mention released reacquired times whilst held organize outer lock condition inspection decide idea inclusion random boolean idea simplifying code resulted em longer em code counter intuitive case convention compelling reason give argument ol li lock locking context code reasons locking share locks li li lock locking resource code central structure protected single lock implemented conditions access structure li ol 

code differs manual implementation lock em lockfoo em em foocondition em true em bar em related part lock implementation takes account em foo em critical section em central em garantee faster case strong contention strong waiting em foocondition em performed case performance reasons code preferrable documented extendable case data protected em lockfoo em needed accessed em lockcentral em case manual implementation lock loses performance gain 
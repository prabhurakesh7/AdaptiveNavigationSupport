changing variable primitive created current primitive mutated 
mutable immutable terms describe ability objects change object oriented languages objective bring relates question primitives data change variable holding immutable object fact creating object primitives data behave similarly immutable objects change variable holding primitive data data created referenced variable existing primitives mutated modified stored data values strong edit strong strong issue strong clear misunderstandings part make clear change variable holding immutable object fact creating object assign variable existing object assigning variable variable case guys brought reference variable object referencing scenario object object world referenced variables meant goodbye world variable referencing string object values goodbye world string object world initialized string immutable object change values string variable variable reference existing object strong strong string object existing object goodbye world string object created code created string object reference correct strong issue strong sum answers strong ulfalizer strong forms variable exist memory address case variables language objective regard primitive type data instance int variable actual memory address type integer initialized reference case variables regard primitive type data objects instance string world variable pointer reference memory address existing holds world content variables primitive type data objective behave memory address variable aka memory address changed words stored memory address variables modified changed language variable behave reference declared pointer type strong ulfalizer strong int ptr ptr pointer variable point variable aka memory address ptr amp initialized int actual memory address holds codes modified stored variable aka memory address ptr pointer variable confirm interpretations correct false 

understand works high level assembly language variables simply locations memory assigning variable stores location high level language perspective mutation purest form declaration definition tells compiler reserve memory variable inside function memory stack global scope data segment assignment simply generates code copy memory location similarly assignment generates code copy stored memory location memory location assume logic holds complex types variables references primitive types refer objects times similar references explicitly define em pointer em variable variable holds address point assign address objects times em included case youre interested em operator address variable address operator pointed object applied pointer heres pointer refer variables times end result code set silly idea c99 support style comments h1 answers issues h1 em caveat bit rusty reading details correct feel free correct em h2 issue h2 assignment effect making refer object goodbye world em em object created shouldnt make difference long created assigned variable created assignment executed program starts wouldnt difference h2 issue h2 sounds high level concepts code correct correct pointer pointer syntactic obscurity makes natural put declaration imo write declaration case things start weird declare variables line talking implemented references bit advanced pointers objects hood jvm move objects memory change address reduce memory fragmentation references remain valid fix pointers objects moved references indices table pointers jvm implementation em pointer em thinking reference pointer field high level ignoring implementation field isnt needed primitive types possibility reuse pointer field store primitive types assignment store directly pointer field reference techniques pretty common side store types pointer place memory overlap assigning types change type 
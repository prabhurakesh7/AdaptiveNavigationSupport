heavy rendering task canvas javafx blocks gui 
create application performs renderings canvas normal javafx blocks gui realy hard press button application code run searched web javafx support background rendering rendering operation strokeline stored buffer executed javafx application thread canvases exchange rendering javafx scene node snapshot snapshotparameters writableimage create image background thread run inside javafx application thread block gui ideas blocking gui rendering operations press buttons rendering performed background paused regularly strong edit strong edited code show background thread sends draw operations exchange canvas resolve problem em rendering operation strokeline stored buffer executed javafx application thread em 

drawing million lines frame simply lot lines takes time render javafx rendering pipeline workaround issue drawing commands single frame render incrementally spacing drawing commands application remains responsive close interact buttons controls app rendering tradeoffs extra complexity approach result desirable simply render extremely large amounts draw commands context single 60fps frame presented approach acceptable kinds applications ways perform incremental render ol li issue max number calls frame li li place rendering calls buffer blocking queue drain max number calls frame queue li ol sample option sample interact scene clicking test button incremental rendering progress desired enhance double buffer snapshot images canvas user doesnt incremental rendering incremental rendering service service facilities track rendering progress relay ui progress bar mechanisms sample play setting vary maximum number calls issued frame current setting calls frame ui responsive setting fully rendering canvas single frame issuing calls frame incremental rendering performed ui responsive rendering operations completed frame em side em weird remove concurrency stuff double canvases code original question single canvas logic javafx application thread initial invocation drawshapes takes seconds subsequent invocations cases application logic system perform task dont initial call slow performance issue javafx canvas implementation related inefficient buffer allocation em em case javafx canvas implementation tweaked hint suggested initial buffer size provided efficiently allocates space internal growable buffer implementation worth href http bugreport rel nofollow filing bug discussing href http mail openjdk net mailman listinfo openjfx dev rel nofollow javafx developer mailing list issue slow initial rendering canvas visible issue large number rendering calls wont effect applications 
fast integer powers 
short answer bad benchmarking methodology youd id figured problem presented find method calculating quickly positive integers typical fast algorithm wanted faster calling math pow naive approach multiplying times edit pointed correctly benchmarking code consuming result totally throws started consuming result naive approach faster fast approach original text blockquote surprised find naive approach 4x faster fast version 3x faster math pow version blockquote test trials million make absolutely jit time warm random values prevent calls optimized lt lt lt lt chose narrow range values wouldnt produce result greater biased larger exponent attempt give fast version advantage pre generating pseudorandom numbers eliminate part code timing understand small exponents naive version expected faster fast version branches generally arithmetic storage operations naive expect large exponents lead fast approach saving half operations case worst case idea naive approach faster fast version data biased fast version larger exponents extra branch code account difference runtime benchmarking code framework official benchmarks toy problem updated warm consume results produces output easypower ms 407261252961037760 naivepower ms 407261252961037760 fastpower ms 407261252961037760 playing parameters random numbers trials change output characteristics ratios tests consistently shown 

issues ol li replace bitwise operations faster li li code decrements performs extra multiplication including cases put part clause li ol guess benchmarking method perfect 4x performance difference sounds weird explained complete code applying improvements verified href http openjdk net projects code tools jmh rel nofollow benchmark faster factor 3x 2x results strong strong integer multiplication fast operation href http stackoverflow questions ab faster faster extra comparison dont expect huge performance improvements values fit advantage fast power algorithm evident larger exponents h3 update h3 author posted benchmark admit surprising performance results common benchmarking pitfalls improved benchmark retaining original methodology shows faster href https gist github apangin 91c07684635893e3f1d5 rel nofollow key improved version ol li algorithms tested separately jvm instances prevent profile pollution li li benchmark called times proper compilation recompilation steady state reached li li benchmark trial separate method avoid stack replacement issues li li replaced hotspot perform optimization automatically li li minimized effect unrelated operations main benchmark loop li ol writing microbenchmarks manually difficult tasks strongly recommended proper benchmarking frameworks href http openjdk net projects code tools jmh rel nofollow jmh 
loop optimization 
made runtime tests loops recognized strange behaviour code wrapper objects primitive types int double simulate io output parameters point watch code objects field access faster primitive types loop prtimitive type result blockquote microtime primitive max br microtime primitive max br microtime primitive max br microtime primitive max 0e7 br microtime primitive max 0e8 br microtime primitive max 0e9 br microtime primitive max 0e10 blockquote loop simple type wrapper object result blockquote microtime wrapper max br microtime wrapper max br microtime wrapper max br microtime wrapper max 0e7 br microtime wrapper max 0e8 br microtime wrapper max 0e9 br microtime wrapper max 0e10 blockquote iterations faster code compiler jvm optimizing code thought primitive types slower objects field access br plausible explanation edited hdouble class tested loops code calculate sum behaviour difference big thought primitive algorithm faster thought calculation takes long field access difference wrapper loop result blockquote microtime wrapper max br microtime wrapper max br microtime wrapper max br microtime wrapper max 0e7 br microtime wrapper max 0e8 br microtime wrapper max 0e9 br microtime wrapper max 0e10 blockquote primitive loop result blockquote microtime primitive max br microtime primitive max br microtime primitive max br microtime primitive max 0e7 br microtime primitive max 0e8 br microtime primitive max 0e9 br microtime primitive max 0e10 blockquote 

easy fooled hand made microbenchmarks em em measure special tools href http openjdk net projects code tools jmh rel nofollow jmh lets analyze primitive hand made benchmark results similar repeat test times interesting methods finally optimized run logging jit compiler activity sign compilation log iteration means methods compiled osr href http stackoverflow questions differences time compilation stack replacement stack replacement mode iteration methods recompiled normal mode starting iteration difference primitive wrapper execution speed youve measured performance osr stub related real performance application shouldnt care question remains osr stub wrapper compiled primitive variable find generated assembly code br ill omit unrelevant code leaving compiled loop primitive wrapper primitive case makes number loads stores stack location wrapper register operations understandable osr stub refers stack interpreted mode local variables stored stack osr stub made compatible interpreted frame wrapper case stored heap reference object cached register 
performance search removal speed removeall 
fun comparing speed call declared micro benchmarks difficult won milliseconds difference results valid ran repeatedly reproducible assume collections tiny consecutive integer elements overlap instance left simply call depends types left collection blazingly fast collection hash map ups closer noticed results explain tests sorted shuffled importance hr weird result removing elements sorted faster removing shuffled list consecutive values faster random values hr suggests lookup sorted call element list left faster shuffled list easy make fact sorted binary search hr results mysterious explain code data structure knowledge processor cache access patterns jit compiler optimizing stuff performed warming run tests times row fundamental problem benchmark 

reason performance difference memory access pattern accessing elements consecutive memory faster random memory access due memory pre fetching cpu caches initially populate collection create elements sequentially memory traversing foreach removeall accessing consecutive memory regions cache friendly shuffle collection elements remain order memory pointers elements longer order traversing collection youll accessing instance 10th 1st 5th element cache unfriendly ruins performance question effect visible greater detail href http stackoverflow questions filtering unsorted list faster filtering sorted list filtering unsorted list faster filtering sorted list 
thread serializable collection atomic replace 
facing problem program multiple threads access server rmi server list cache performs expensive computation changing list computation finished list serialized client strong problem strong list changed serialized client requesting data thrown resulting rmi call deserialization client side kind list structure stable serialization possibly changed thread strong solutions strong ul li regular arraylist set working concurrency li li deep copying entire structure serialization faaar expensive li li expensive copies list strong strong li ul revealing strong problem strong atomically replace element list thread delete add expensive doable locking list threads sequence strong question strong blockquote implementation collection thread threads modify elements bonus list serialization creating snapshot serialization meh blockquote illustration problem compute add list remove list serialize 

wrong initial thought bad idea copies perform shallow copy copying references deep copy copying objects offered lot needed functionality remaining problem complex fit case instance class called needed store replace updated instance overwrite choose wether wanted equality return minimally objects options work ul li objects set bother adding object li li added removed li ul list offers fits lets replace object custom comparison utilized 
performance collections emptylist empty arraylist jit compiler 
performance difference empty jit compiler imagine jit compiler doesnt inlining static method calls executed method depends type strong edit strong returns immutable list mutable object pass method parameter method doesnt modify list restrict possibilities jit compiler optimize method simple clarify called method jit compiler inline made calls wouldnt correct 

h1 disclamer h1 written applies href https en wikipedia org wiki hotspot rel nofollow hotspot jvm h1 short answers h1 blockquote jit compiler doesnt inlining static method calls executed method depends type blockquote opposite true answer blockquote performance difference collections emptylist empty arraylist jit compiler blockquote rare cases microbenchmark results blockquote called method arraylist jit compiler inline arraylist made calls collections empty wouldnt correct blockquote short answer depends jit compiler smart recognize monomorphic bimorphic polimorphic call patterns provide implementations h1 answer h1 order detailed answer recommend read href http shipilev net blog black magic method dispatch rel nofollow post black magic method dispatching words blockquote c2 interesting profile guided optimization based observed type profile single receiver type call site em monomorphic em simply check predicted type inline target directly optimization applied receiver types observed call site em bimorphic em cost branches blockquote lets jmh haven learned jmh suggest read href http openjdk net projects code tools jmh rel nofollow results case monomorphic bimorphic calls jit replaces virtual call concrete implementations case output case jit inline implementation true virtual call advantages inline functions methods lets compiler generated code jit replaces virtual call 
high performance lock free collection specific requirements 
suitable candidate high performance concurrent collection requirements ol li number elements collection small elements rarely li li main case iterating elements lot super fast lock free li li occasionally element removed iterator remove method preferably work fast significant iterator method li li order elements insignificant doesnt matter elements inserted collection li li preferably standard library li ol considered concurrentlinkedqueue lt found mentions leaking memory design call poll method case posts mentioning found mentions addressed considered concurrentskiplistset lt effect sorting performance dont care order 

fast solution concurrentlinkedqueue problem memory leak iterator remove fixed part href http bugs view bug bug id rel nofollow http bugs view bug bug id removed concurrentlinkedqueue nodes gced successfully performant solution ol li dont iterators collection collection iterator prepares instance iterator btw method isnt free time iterate collection iterator spend cpu time instructions allocate memory object number instructions constructor sources concurrentlinkedqueue itr concurrentlinkedqueue itr removing object eden minor gc li li plain array direct indexing fastest technique iterating copyonwritearraylist implement collection plain array iterate number items add remove items rarely youd prefer remove iterating remove index li ol usage similar copyonwritearraylist btw thread modifies collection single writer readers rid lock guarantee visibility writer readers replace classic lock busy wait lock free collection latency important main thing understand cases performant solution specific requirements write piece fine tuned code dont pay things dont high performance low latency apps dont common 3rd party libs main paths 
surprising performance differences stream reduce stream collect 
compare java8 stream terminal operations terms parallel performance lets java8 parallel stream computes admittedly weird algorithms performance results surprising remarks ul li synchronize accesses array parallel li li expected yield performance times slower synchronized li li fastest algorithm sequential recursive show huge overhead parallel stream management li ul didnt expect performance worse 

basically measuring initial overhead code executed time optimizer didn work measuring overhead loading verifying initializing classes evaluation times decrease evaluation reuse classes loaded previous evaluation running evaluations loop changing order give picture predictable result simple recursive evaluation smallest initial overhead doesn require loading api classes hr run code multiple times sophisticated benchmark tool guess results similar mine outperforms faster single threaded approach reason slower wrong queried thread distinct container accumulator function em em additional synchronization important combiner function work correctly joining result containers threads single result correct approach system performance par approach array mutable container change immutable nature advantage straight forward equivalent performance methods correctly hr don programmers create referential lambda expressions straight forward recursive function method code don call directly hr final bad parallel execution stream predictable size independent operations outperform solutions significantly 
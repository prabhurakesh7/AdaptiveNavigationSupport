performance optimization performing expected 
written programs implementing simple algorithm matrix multiplication contrary expectations program runs 5x faster program novice suggestions change program make run faster programs borrow code data blog post href http martin thoma matrix multiplication python cpp rel nofollow http martin thoma matrix multiplication python cpp current compilation flags current compiler runtime versions computer era core i3 laptop running windows mingw current performance results program program link 2000x2000 test case href https mega nz sglwxzqb hbts ulznr4x9gzr7bg ej3xf2a5vuv0wtduw kqfma rel nofollow https mega nz sglwxzqb hbts ulznr4x9gzr7bg ej3xf2a5vuv0wtduw kqfma link 2x2 test case href https mega nz qwkv2sii atfguxpv5bqeztt9ehnnn36rnv4sgq0 sjzitjife8s rel nofollow https mega nz qwkv2sii atfguxpv5bqeztt9ehnnn36rnv4sgq0 sjzitjife8s advice explaining wrong implementation running slower appreciated edit suggested modified programs perform multiplication read arrays print number performance results program slower io accounts part difference 

analyze execution creates temporary executable module disappears assume execute sse instructions speed unrolls loop clang disable sse instructions compiling clang clang optimises loop sse instructions gcc doesnt resulting code times slower changing code constant dimension compiler dimensions height width gcc compiler generates code takes 8s machine compared 27s variable clang compiled code marginally faster noise id conclusion quality cleverness compiler highly affect performance tight loops complex varied code solution generate code simple easy compile problems code rule guaranteed expect compiler profiling determine number loops strong edit strong result determine reading file taking long time kind profiling tool determine actual input lot cpu time engine time compiler profiling determine number times piece code hit big projects unroll loop determine runtime number iterations loop code loops compiler job size values telling runtime isnt initially manages improve performance time due runtime works doesnt leave binary code analyze key actual operations simple logic simple awful lot trivial implementation benefit manually unrolling loop 
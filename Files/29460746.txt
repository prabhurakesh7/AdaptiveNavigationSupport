ideas improve groovy performance specific test 
encountered significant performance issues converting existing batch process existing batch process written runs periodically reading data data sources performing data transformation discovered significant performance degradation unexpectedly high gap times converting code code href https github nicolas martinez grava speed test rel nofollow https github nicolas martinez grava speed test simplified shows problems discovered simple loop filtering collection closures setup project easily cloned locally executed highlight groovy code code results test 342ms 30ms suggestion improve groovy performance team moving groovy advanced features offers hard justify high gap performance encountered hardware profile reported version version defined href https github nicolas martinez grava speed test blob master pom xml rel nofollow pom xml update ol li made suggested modifications code li li added repeat test method call test li ol ran runs tests separately startup included tests results running method times jvm process allowing warm blackdrag takes longer warm warm cycle takes times longer execute initial warm cycle excluded updated code branch review 

roughly guide lines performance tests general ul li ensure measure 1s avoid timing errors computer clock li li give groovy versions computer specs compare things li li long warm phase li li dont run multiple micro benchmarks li li measuring multiple iterations average preferred measuring single iteration li ul performance testing wide field micro benchmarks test test giving hints case details platform test peak performance average performance initial performance startup cost jvm partially interpreted partially runtime compiled code interpreted code transformed compiled code depends number iterations method code called types code size lot things peak performance junit tool jmh handles warm times stops stabilization phase lot class loading time groovy runtime default groovy methods loaded easily half time observed effectively code executed point prevent loading groovy meta class system warm cost mention jvm warm cost original code computer original code 752ms adding warm single iteration 20ms logical disconnects range list call collect produce list copying element collect transform elements longs dealing integer objects convert long calling correcting things reduce execution time half computer warm phase warm phase difference warm corrections 10ms 50k elements compare version 5ms find short test redo test million elements 73ms 200ms groovy changed version integer adding type hint enable primitive optimizations improve performance 120ms case running invokedynamic performance invokedynamic version depends extremely jvm version improving performance test assume 
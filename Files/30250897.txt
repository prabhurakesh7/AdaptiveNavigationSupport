multithreading efficient coordinate finding result 
clear method describe operational hoping improve throughput method works works scale throughput task hand improve performance scoring algorithm returns score collection tasks collection tasks perform scoring task checks score updates score synchronized fashion give insight scale working task takes fraction millisecond complete thousands resulting hundred milliseconds find execute scoring algorithm hundred times minute result spent running scoring algorithm thread pool threads virtual cores tasks ms threads machine virtual cores tasks ms suspect add threads thread pool performance worse synchronization score threads contending lock bit searching find satisfactory find alternatives thinking collecting scores storing sorted order sorting tasks completed unsure improvement thoughts efficient collecting score heres current methodology 

ill granted fact compute individual score separate task submitted benefits overhead isnt worth youd implement returns score object score pertinent results executed successful invocation tasks results examined main thread obtain constraints optimization href http docs oracle javase docs api util concurrent atomic doubleaccumulator html rel nofollow intended cases element array synchronization track information score similar creating data object carries task identifier score needed properties href http docs oracle javase docs api util concurrent atomic atomicreference html accumulateandget util function binaryoperator rel nofollow accumulators tasks initialized sort recursive divide conquer approach resulting blocking equally sized tasks fork join framework underlying parallel good fit point threads decreased performance measuring fewer threads prudent 
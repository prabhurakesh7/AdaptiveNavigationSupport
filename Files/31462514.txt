indirect increment faster direct 
question asked member disappointingly deleted comments measurements flawed make sense reproduce original problem small benchmark href http openjdk net projects code tools jmh jmh benchmarks shows works times faster optimization assume work bit slower involves extra intermediate operation jit compile similar 

approach things ol li reproduce reproduces li li generated assembly long story short produces lot generated code limit loop unrolling affect performance pretty lets run score lower difference excellent li li generated code pops eye interesting lets properly characterize workload normalizes hardware counters benchmark op lets benchmarks comparable number instructions slower takes cycles cpi ideal produces close ideal cpi closely cache misses tlb misses slow benchmark lots branch misses aha generated code li li lets generated code conveniently highlights jumps strong directinc strong strong indirectinc strong notice predictable branches hotspot profiles branches emits conditional move branch profile branch flat words dodge branch misprediction paying bit added latency conditional move case switch special em em alternatives speculate increment folded cmov generally speaking hotspot stored default blew li li confirm hypothesis lets make case cover cases measure time options op li li confirm li li drink li ol 
asynctask activity user navigated 
android work separate cases work work overriding user navigate close app work background question user navigates closes app reference user closed guess destroyed user navigates test device reason call methods 

simple answer discovered h1 memory leaks h1 long part app holds reference strong destroyed strong stick releases reference bad consequences app crashing worst consequences dont notice app reference released ages ago time user leaks memory device full seemingly android kills app consuming memory memory leaks single frequent worst mistakes android questions stack overflow hr h2 solution h2 avoiding memory leaks simple strong strong reference ui component listener pattern hold strong references hr h1 examples h1 h2 referencing h2 correctly implemented illustrates perfectly referencing garbage collected create constructor called seconds exist anymore call exists long returned null garbage collected worry meantime user quit app eligible garbage collection immediately finishes time sees memory leaks problems hr h2 listener h2 similar similar hr h2 consequences listener h2 thing aware consequence listener imagine implement listener interface unusual similar sneak code knowing consequences difficult debug noticed wrong figuring continue reading problem simple create instance reference pass start task method finishes local variables eligible garbage collection strong reference left instance passed garbage collected finishes happen executes fast garbage collector collected instance work time debugging issues nightmare moral story aware strong weak references objects eligible garbage collection hr h1 nested classes h1 thing memory leaks stack overflow people nested classes wrong spot memory leak exact problem figured problem daily people carelessly implementing stuff knowing wrong problem consequence works based fundamental feature excuse people implement things drunk dont lets simplify problem imagine nested class access members class inside class print access members private br reason nest classes implicitly creates reference inside reference access members inside context memory leaks poses problem dont ill strip parts dont matter nested class inside nested class static access members inside doesnt matter doesnt access members static nested class implicitly creates reference inside seemingly visible memory leak fix simple add word static missing keyword simple nested class difference memory leak completely fine code understand issue core works understanding crucial issue anonymous classes static nested classes immediately memory leak million times worse angle terrible code avoid costs hr hope helped understand problem write code free memory leaks questions feel free 
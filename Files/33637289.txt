jms transactions work concurrent consumers 
hey queue messages sequential processing processing involves calling web service make message retrieval transactional exception midway transaction rolls back message isnt lost whats needed high availability message consumer instances listener listening queue transaction ensure message isnt retrieved instance listener completely processing message make message queue fully processing additional configuration needed mq listener websphere mq message broker spring integration retrieving messages strong edit strong token thing concern high availability queue manager queue holds token part queue manager failover control queue longer accessible kinda means control queue ready case failover listeners listening dr control queue normal operations lets mechanism make data queue perfectly replicated listener instances failover initiated stop listening control queue normal ops switch secondary listener instance actual producer puts messages queue notify listener instances stop listening normal ops control queue switch secondary kinda tricky intermediate connection problem normal ops queue manager isnt corner case high availability control queue care kinda problem sharable low load scenarios occasional spikes load slump periods night stuff token system reactive periodic thing lets dont messages hours listeners constantly checking queue coz token message triggering instance makes poller multiple listener instances polling times hour event driven se question inserting token message install failback extra manual step manually inserting token token lost failover make listener instances listener instance doesnt find message kinda means listener instance token logic separate put meaningful info token message utility triggered insertion ui guess arent problems extra overhead wouldnt needed poller implementation whats bothering 

passing tokens heres works create queue place single message start program logic ol li token message token queue syncpoint unlimited long wait interval option li li put token message back token queue uow li li message application queue uow li li process applications message li li commit uow li ol app instances input handle queues app instance app instance handle errors due exclusive queue token message app hold syncpoint time apps actively processing application message app queue dependent successful token queue application messages processed strict sequence em app process application messages concurrent threads token messages token queue adds token message token queue strict sequence processing lost reason read write access queue granted app service account common token message structured app recognize stray unrelated message lands app ignore throw warning em fairly distribution messages apps apps wildly em em distribution queue handles managed stack instance commits uow instances handle top stack message handling message instance committed top stack listening instances chances traffic assures messages processed queue time strong em em strong assure wont dupes syncpoint messages lost scenario message retrieved processed call fails case transaction rolled back message phase commits xa processing message rolled back nice thing token message syncpoint fixes issue orphaned client channel takes release transaction connection messages older message held syncpoint orphan transaction eventually channel agent times releasing message back queue effectively changing position em em messages processed sequestered scenario token message sequestered type connection loss message processing temporarily stops waits channel agent time happen issue command instance uow hr strong em update based additional question details specific answer em strong blockquote queue holds token part queue manager failover control queue longer accessible kinda means control queue ready case failover blockquote token queue unavailable application queue needed app requires ha multi instance qmgr hardware ha cluster share disk qmgr failover app connected physical location app dr replicate disk qmgrs logs data directories dr site listening instances processing primary data center blockquote listener instances failover initiated stop listening control queue normal ops switch secondary listener instance blockquote wmq reconnectable clients long time multi instance features v7 made reconnecting drop dead simple admin job make instance app token trigger queue outage client retry requiring application code drive finds whichever instances connects blockquote actual producer puts messages queue notify listener instances stop listening normal ops control queue switch secondary blockquote question serialization concurrent consumers design producers consumers rendezvous common location problem overlap complicated serialization question explore topologies blockquote token system reactive periodic thing lets dont messages hours listeners constantly checking queue coz token message triggering instance blockquote triggering token trigger message filesystem database lock order facilitate serialization whichever listener token message unlimited wait application queue listeners unlimited wait token trigger queue basically sit idle message arrives reconnections polls cpu cycles alive time application queue rolls back uow token queue passes token listener blockquote question inserting token message install failback extra manual step manually inserting token token lost failover blockquote experience mq losing persistent messages syncpoint wrong situation strict serialization requirements active instance queue reason instances application queue pre defined disk replication instance token trigger queue predefined alongside token trigger message waiting queue surely thing face strict message order requirements queues surely disabled blockquote make listener instances listener instance doesnt find message kinda means listener instance token blockquote correct listeners em em check queue depth transactions input handles generally wise avoid mixing application logic control logic blockquote logic separate put meaningful info token message utility triggered insertion ui blockquote coders handle structured data app messages perceived significantly difficult someones wrong write instance formatted token trigger message queue offload file reinitialize queue qload clear queue load file strong strong utility open queue exclusive check depth check handles prior performing magic consulting clients typically define service initializes queue mq startup em em provide feature application gui operations support staff long app managing token trigger queue exclusive access operations doesnt matter instances control app rule structure message send commands listeners real token message messages command app instances things nice transactional ping capability drop ping messages token trigger queue single uow app instances listening guaranteed contact detect zombies depending instrumentation required listeners react ping providing status uptime messages processed log console event queue blockquote guess arent problems extra overhead wouldnt needed poller implementation blockquote good pretty standard stuff problem lies requirements serialization conflicting ha dr global transactional atomicity implement single logical queue multiple physical locations ibm mq attempted provide messaging engine closest mq mq appliances memory memory replication message transaction data good miles light speed latency begins significantly impact throughput doesnt handle dr fact em em short synchronous replication recovery point dr datacenter 
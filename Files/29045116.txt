jni libraries deallocate memory garbage collection 
jcuda jni objects smart deallocate garbage collected understand work situations work situation followup question accomplish mode set build layer abstraction answer dont edit referring native objects created jni objects aware objects treated equally garbage collection 

libraries deallocate memory due garbage collection jcuda option mode reason simple work youll pattern native memory allocated object serves handle native memory line object scope eligible garbage collection issues hr strong strong garbage collector strong strong destroy object strong strong free memory allocated native call youll free native memory explicitly calling leaving method hr strong strong dont object garbage collected garbage collected common misconception object garbage collected longer reachable necessarily true href http stackoverflow bmargulies pointed answer blockquote means object finalizer makes jni call free native memory blockquote viable option simply override method handle objects call authors javacl library gpu conceptually similar jcuda simply work object longer reachable strong strong garbage collected immediately simply dont method called easily nasty errors mb gpu memory objects allocating 10mb gpu memory full objects occupy bytes method called runtime application jvm simply em em reclaim bytes memory omitting discussions hacky workarounds calling bottom line work hr answering actual question href http jcuda org rel nofollow jcuda low level library means full power full responsibilities manual memory management inconvenient started creating jcuda originally intended low level backend object oriented wrapper library creating em robust stable universally applicable em abstraction layer complex general purpose library cuda challenging dare tackle project complexities implied things garbage collection 
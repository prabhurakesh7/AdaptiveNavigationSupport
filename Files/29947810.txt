reusing instances objects creating update 
differences pitfalls reusing instances objects creating time em swap buffers em em background em game engine project mine writing em triplebuffer em versions object em version em em current version em em future version em objects made reading state current version applying future version made objects resp applicable buffers em swapped em future objects current objects current objects objects objects ul li em em discarded objects allocated iterating em em current objects li li em em em em future objects values em updated em resp overridden iterating em em current objects li ul em explanations em ul li reusing overwriting values instance values effectively changing state instance li li cloning creating instance data instance applying li ul em case em objects swapped 30hz meaning recreated times cloning current reusing obsolete overriding state range complexity properties hundreds properties em depth levels em em depth levels em buffered objects map unique objects make recreating reusing strong require strong iterate current objects em components em shorter em objects turn make em em considerations em parts engine event firing magic work time snapshots objects decision recreating reusing lead ul li em recreating em means safely pass references object object immutable time em current object em li li em reusing em means create copies em current object em part guarantee event processed object reused li ul 

good reason discard objects create reduce chances bugs reference object bad side effects discarding creating objects cleaner conceptually make code easier read debug maintain general case garbage collector smart make discarding creating object expensive situation write clearest straight forward code means creating object test performance bottleneck optimization words avoid href http programmers stackexchange questions premature optimization root evil premature optimization 
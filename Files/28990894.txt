ndk work android order ndk jni 
ndk jni jvm code related android project code runs ndk method ndk jni library difference ndk jni question poorly worded difficulties ndk implemented android project 

ndk compile asm code binaries lot things ndk compiling executables static prebuilts end context android application obtain em files em shared object libraries load files map functions implemented inside specific case android application project code em native activity em sample ndk principle files loaded inside art dalvik context android application executed context dalvik virtual machine art order integrate code environment jni em native interface em jni jni mechanism load file jni onload function called exists functions starting mapped methods methods declared classes keyword em native em implementation file file loaded em system loadlibrary em static block class methods declared em native em runtime execution reaches method implementation em native em inside file file loaded native implementation directly executed returns code execution continues jni jni header methods access environment javavm jnienv manipulate create access primitives jint jlong objects jobject jclass exceptions jthrowable properly packaged installed loaded system loadlibrary files put specific places ul li strong libs cpu abi strong inside eclipse project li li strong jnilibs cpu abi strong inside android studio project li li strong jni cpu abi strong inside aar li ul application packaged apk libs inside strong lib cpu abi strong folders installation libs target platform installed strong nativelibrarypath strong lt device inside apps strong legacynativelibrarydir cpu arch strong device strong cpu abi strong em armeabi armeabi v7a arm64 v8a x86 x86 mips mips64 em depending architectures youre targeting libs compiled 
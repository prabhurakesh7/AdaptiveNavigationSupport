extracting static final optimization 
method set creating custom comparator wondering makes difference performance memory garbage collection point view polluted outer space reason feel em compiler em figure optimize shouldnt extract thing strings temporary strong immutable strong objects declared method make difference extract variable aware impact performance boost give question em em difference howsoever negligible 

difference ul li cpu affect assigning static reduces amount work allocate comparator time li li gc effect assigning object time immediately discarding young gc cost assigning variable increase gc times marginally extra set references walked dead objects cost live objects li li memory effect assigning comparator constant reduce memory invocation method require exchange low constant overhead moved tenured gc space li li risk reference escapes classes pointers class constructed class comparator returned method created strong reference parent object escape prevent gc parent purely gotcha creep code problem li ul hotspot good inlining recognise comparator allocated heap moved constant depend contents treeset implementation treeset simple small inlined treeset coded generic type object worker optimisations jvm apply assume treeset types treeset make assumptions comparator past difference versions primarily object allocation final keyword improve performance hotspot ignores final keyword interesting behaviour lambdas variant run javap class jvm code cool thing object construction lambda invokedynamic higher cost time called effectively cached 
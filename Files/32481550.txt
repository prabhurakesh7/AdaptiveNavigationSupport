extend list add fields 
question framed easily applies collections framework make type store counter additions integral part lists operation doesnt alter list adding additional functionality knowledge list adt storing arbitrary data list element assuming data properly managed elements added removed case altered list adding additional functionality behavior additional state part purpose type specification inheritance implicit restriction taboo deprecation poor practice collections types treat specially referencing mutate iterate normal ignore payload problematic persistence copying expect carry additional data maintained places accept object check list simply treat arbitrary application contributions manage specific concrete types implementation constantly produce issues instance slicing ignoring type fields bad idea extend collection composition additional data managed job persistence copying account concrete types including additional fields 

aspect classes inherit em classes em means meaningful methods lists judged equal instance class contract list compared current list list implementation add em item em class extend include item methods lists payloads considered map set plain comparison algorithm fact impossible extend class adding item youll end breaking contract breaking symmetry plain return true compared payload reverse comparison wont return true youll break transitivity means basically proper extend class adding behavior list logs avoid breaking contract composition composition strong implement strong lists accept implements values iterating answer based item effective 2nd edition joshua bloch 
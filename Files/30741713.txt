concurrency jpa db applications 
developing spring mvc jpa web application application deployed live db application interacts dotnet vb applications time managing concurrency jpa app version column issue running apps time database systems tables build application spring mvc jpa db future issues running apps time terms persisting tables apps 

multiple applications accessing database tables concurrency nightmare adding version column tables application concurrency management mechanisms common problems encountered sharing database applications assuming read write access order ol li strong concurrency mismatch strong imagine application optimistic locking pessimistic locking locking maintained teams central architecture group handing good application architecture advice developers end causing concurrency hell li li strong deadlocks strong imagine application isolation level transactions performing long running operations database causing queues deadlocks timeouts applications corrupt data end errors due deadlocks timeouts reducing usefulness li li strong data validity strong common developers memory caches storing fixed slow changing data save repeated database roundtrips jpa application backed hibernate developers level cache application updates database cache holding stale inaccurate data li li strong data integrity strong applications parts data allowed update common data independently referential integrity maintained business rules duplicated applications li li strong team communication overhead strong team teams informed make schema step toes reduce agility teams agree required team priorities aligned li li strong schema errors strong deletes renames moves archives tables columns required application li li strong access control strong underlying data sensitive requires authentication authorization access control checks duplicated applications li li strong ownership strong owns common tables challenge team stakeholders roadmap constraints priorities li li strong portability strong underlying database vendor type changed day applications changed li li strong auditing versioning strong common data audited versioned multiple versions data rows code duplicated applications built database easy database knowing application user changed record database portability affected syntax vary database vendor li li strong database specific optimizations strong scenarios reporting require native queries optimizations hard perform orm technology jpa multiple applications require access optimized queries functionality built database stored procedures duplicated applications possibly ways li li strong archival partitioning strong applications archival partitioning requirements makes everyones met equally li li strong standardization strong teams allowed manage common database objects things data dictionary naming conventions managed table teams differently annoyingly named columns constraints li ol approach expose common database tables service service things consistent controlled times common team handling service ensure unexpected minimized communicated affected parties timely manner 
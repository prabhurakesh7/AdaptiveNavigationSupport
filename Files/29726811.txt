opengl v3 2d game efficient rendering 
confused vbos modern opengl direct question end post bundle youve insigt id greatful reply reply regard compleate idiot knowledge whatsoever history game top 2d game immideate mode render 2d sprites actual texture coordinates texture atlases static predefined seperate class quad coordinates defined entity updated game progressed rendered simply bound specific texture called glbegin triangles called visable objects render method turn quad coordinates texure coordinates renderer class made opengl calls flushed texture calls glend atlases order proper depth times change move vbos shaders times past failed misserably simply things find google give complete understanding speed game basics sending information bus gpu render call simply store ill initization phase shaders calculate end result idea texture coordinates static change make sence store gpu coordinates correspond quad triangle thinking floats renderable object game kind index passes attribute vertex shader vertex shader index lookup texure coordinates vbo feasable solution implement quad vertecies lost move arround constantly visable dissapear means quad vbo change render call code updates vbo ugly ul li store quad coordinates array li li create floatbuffer put li li manipulate buffer li li send buffer vbo li ul expensive dont understand delete entry entity moves screen manipulate entry entity moves update vbo manner render call whats performance gain loss track depth resulted image 2d depth order rendering making object2 rendered ontop object1 vbo depth coordinate enbale depth stuff give performense hit 2d factor utmost respect 3d 2d advantage fact theory yield performance gathered doesnt case opengl seemes order render 2d stuff translate 3d whats processes harware odd end result screen 2d circumvent save gpu work 2d 3d 2d words efficienty change modern opengl 

foremost important key insight em vertices position em vertex tuple attributes preset mode drawing calls calling em glvertex em change attributes end vertex lets step back vbos moment glbuffer data plain client side vertex arrays long mode youve arrays position layout values values layout identical element attributes succession trivially common texture coordinate array matching layout quads mode calls draw sharing nows time work answer patient wait youre hr em intermission em hr putting geometry data arrays thing brainer opengl pretty introduces concept called em vertex arrays em opengl vertex data vertices draw vertices cherry pick arrays list indices vas draw triangle 0th 1st 3rd vertex key difference plain vertex arrays vbos vbos place data opengls custody youve understood vas understoof vbos unlike vas change vbos contents effortless difference shaders longer kind attribute predefined generic vertex attributes set save overhead uploading updated data depends expensive data gpu eventually packing coalesced buffer data upload transfer beneficial saves call overhead chunk glvertex call 
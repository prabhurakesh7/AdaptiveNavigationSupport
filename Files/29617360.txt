written utf character file utf charset output stream resulting data file utf 
created simple program utf charset save utf16 character save utf save utf characters whats difference utf utf test characters unicode utf range unicode br unicode sample program data written files utf utf br br size files utf utf console output br console output br default charset utf br somefileutf size br somefileutf size br somefilenull size utf save bits unicode fine fine uff 

blockquote created simple program utf charset save utf16 character blockquote utf utf encodings unicode character set encodings designed support unicode codepoints present foreseeable future blockquote save blockquote support unicode codepoints converting utfs loss operation design blockquote utf save utf characters whats difference utf utf blockquote utf primarily preferred utf ol li utf backwards compatible 7bit ascii lot legacy code migrated utf breaking li li languages latin based utf compact utf saving memory disk space bandwidth cases primarily asian languages symbols utf compact utf li ol blockquote sample program br br data written files utf utf blockquote em represent em unicode codepoints em rendered em unicode aware text viewer editor physical bytes blockquote size files utf utf console output blockquote chosen unicode codepoints require utf surrogate pairs encode bytes bytes utf utf bytes size difference reduced byte character writing longer strings bigger mix low high codepoint values wider variation file sizes blockquote utf save bits unicode fine fine uff blockquote utf utf variable length encodings utf variable lengths utf codepoints utf 8s byte formats fit utf 16s byte format making utf closer fixed length utf means utf easier seek forwards backwards jump bytes codepoint utf jump bytes codepoint decoding logic bit complex utf utf mind windows adopted unicode utf existed codepoints time easily fit ucs fixed length encoding wasnt unicode outgrew ucs utf invented replace late write code migrated unicode utf maintain backwards compatibility ucs unicode data real world fit ucs higher codepoints require extra bytes encode utf surrogates makes utf suitable choice processing data compromise memory usage processing overhead utf dealing ascii characters utf backwards compatible ascii suitable format storing exchanging data 
asm initializing classwriter difference compute maxs compute frames 
maintainer href https github fge grappa rel nofollow grappa package generates parsers runtime code asm generate class extending parser class migrated asm asm generating jvm bytecode generating jvm bytecode succeeded generate jvm bytecode idea em em works basically ul li changing argument classwriter constructors prior li li changing argument call method li ul dont understand works reasons ul li calls read instructions removed li li em added em argument constructors failed point tests declare error instance field suppose argument initialized constructor li ul tests work process heavier tests goal id understand modifications worked 

h3 background h3 function recent versions jvm classes stack map method code map describes layout stack key points jump targets methods execution previous versions jvm compute information computationally expensive requiring information jvm verify frames work significantly easier recalculating em compiler em generate frames difficult asm compute similar jvm required class files maximum stack size number variables method verify calculate similar reason stack frames computationally expensive strong strong failed add probable answer lies documentation place confused strong computeframes implies computemaxs strong h3 question h3 calls required point asm recalculate frames max values ignore arguments give remove instruction h3 question h3 explained sufficient key part flags break tests provide exact code source diving source doesnt reason break code 